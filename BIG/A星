https://zhuanlan.zhihu.com/p/385733813

启发式算法，即优先搜索最有可能产生最佳路径的格子。
对于任意一个格子n，其估价函数如下：
f(n) = g(n) + h(n)
其中 g(n) 指的是从起始格子到格子n的实际代价，而 h(n) 指的是从格子n到终点格子的估计代价。

其中，此时格子0周边格子的g(n)应该是g(0)的值加上自己到格子0的距离。例如格子1此时的g(1)应该为g(0)+14=24，即2-0-1的顺序。
但是由于格子1在第一步已经算过了，当时g(1)=10，2-1的顺序。这里我们【【【要用较小的那个值】】】，因为g值小，说明路径短。格子3,4,5同理。
而格子6之前没有计算过，因此f(6)=g(6)+h(6)=(g(0)+14)+h(h)，顺序2-0-6

其中，每个格子中会记录他的parent是谁，即指向、上家

其中，距离的计算可以折中欧几里得（点到点连接）和曼哈顿（x轴差值和y轴差值之和）而采取：
对角线+直线距离
既然我们可以对角线移动，那么我们就可以根据水平方向的差值与竖直方向的差值中较小的那个值，计算出对角线，然后再平移。示意图如下：
这样不考虑障碍物的情况下，肯定等于格子n到终点的最短实际距离。
但是由于计算对角线同样需要开根号以及浮点数。为了加快计算，我们可以假设两个格子间的距离为10，然后直接认为对角线距离为14（不是根号20了），这样就可以避免浮点数和根号运算了。

其中，可以发现整个过程都要频繁的用到了增删以及查询，因此open和close使用了Dictionary。

都说好，但我自己没看：http://theory.stanford.edu/~amitp/GameProgramming/
