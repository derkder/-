move可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。

左值：可以出现在 = 左边
右值：只能出现在 = 右边

左值：指表达式结束后依然存在的持久对象。可定位的变量，可以取地址
右值：表达式结束就不再存在的临时对象。只读变量，不可取地址









.左值引用（引用了左值）&
左值引用就是我们平常使用的“引用”。引用是为对象起的别名，必须被初始化，与变量绑定到一起，且将一直绑定在一起。
我们通过 & 来获得左值引用，
type &引用名 = 左值表达式；
可以把引用绑定到一个左值上，而不能绑定到要求转换的表达式、字面常量或是返回右值的表达式。举个例子：
int i = 42;
int &r = i;    //正确，左值引用
int &r1 = i * 42;   //错误， i*42是一个右值
const int &r2 = i * 42; //正确，可以将一个const的引用绑定到一个右值上


右值引用&&
右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。
它的主要目的有两个方面：
消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
能够更简洁明确地定义泛型函数。
右值引用就是必须绑定到右值的引用，他有着与左值引用完全相反的绑定特性，我们通过 && 来获得右值引用。
右值引用的基本语法type &&引用名 = 右值表达式；
右值有一个重要的性质——只能绑定到一个将要销毁的对象上。举个例子：
int  &&rr = i;  //错误，i是一个变量，变量都是左值
int &&rr1 = i *42;  //正确，i*42是一个右值




右值引用和左值引用的区别
左值可以寻址，而右值不可以。
左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。
