move可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。
还有一种说法是move用来做所有权转移避免复制 e.g.
  int main(){
    std::vector<Test>v;
    v.emplace_back(Test{});
    std::cout << &v[0] << '\n';
    std::vector<Test> v2{ std::move(v) };
    std::cout << &v2[0] << '\n';
}
打印的地址完全一样，代表并没有拷贝元素，而只是转移所有权，转移指向实际数据的指针
避免大量构造和析构调用，提高了效率。




左值：可以出现在 = 左边
右值：只能出现在 = 右边
左值：指表达式结束后依然存在的持久对象。可定位的变量，可以取地址
右值：表达式结束就不再存在的临时对象。只读变量，不可取地址


.左值引用（引用了左值）&
  左值引用就是我们平常使用的“引用”。引用是为对象起的别名，必须被初始化，与变量绑定到一起，且将一直绑定在一起。
  我们通过 & 来获得左值引用，
  type &引用名 = 左值表达式；
  可以把引用绑定到一个左值上，而不能绑定到要求转换的表达式、字面常量或是返回右值的表达式。举个例子：
  int i = 42;
  int &r = i;    //正确，左值引用
  int &r1 = i * 42;   //错误， i*42是一个右值
  const int &r2 = i * 42; //正确，可以将一个const的引用绑定到一个右值上


右值引用&&
      右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。
    主要目的：
      右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，避免拷贝
    使用方式：
      右值有一个重要的性质——只能绑定到一个将要销毁的对象上。举个例子：
      int  &&rr = i;  //错误，i是一个变量，变量都是左值
      int &&rr1 = i *42;  //正确，i*42是一个右值
    具体用途举例：!!!!!!
      https://blog.csdn.net/wdl20170204/article/details/111615408
      //ReturnRvalue()函数本身返回的就是一个右值
      T && a = ReturnRvalue(); //#1 声明了一个名为a的右值引用，其值等于ReturnRvalue()返回的临时变量的值
      T b = ReturnRvalue(); //#2 则是通过函数返回的临时量再进行构造生成的值。
      //可以看出这样可以避免大量构造和析构调用，提高了效率。
