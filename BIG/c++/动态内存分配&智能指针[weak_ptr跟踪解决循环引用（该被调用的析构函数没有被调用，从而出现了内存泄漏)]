为什么需要动态内存分配？
在C++程序中，所有内存需求都是在程序执行之前通过定义所需的变量来确定的。 但是可能存在程序的内存需求只能在运行时确定的情况。 
例如，当需要的内存取决于用户输入。 在这些情况下，程序需要动态分配内存，C ++语言将运算符new和delete合成在一起。

1.C++中通过new关键字进行动态内存申请
2.C++中的动态内存分配是基于类型进行的
3.delete关键字用于内存释放

ListNode *list=new ListNode(0);









智能指针（实现为计数原理）
动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。
为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。
标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。
标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。
共享指针（shared_ptr）：资源可以被多个指针共享
独占指针（unique_ptr）（调用 move() 函数相互赋值）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。
弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。
智能指针的实现原理： 计数原理。




weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？
一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。
