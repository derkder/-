原则一：结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。
从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，//！！因此元素放置的！位置！一定会在自己宽度的整数倍上开始!!/


原则二：在经过第一原则分析后，检查计算出的struct存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。




示例 1：
struct A{
    char a;
    short b;
    int c;
};
分析：第一个成员的偏移量都是0；一般可以不看，a的大小为1，所以成员b的偏移量为1，b的大小为2，1不是2的倍数，所以应该将1+1，成为2的倍数，成员c的偏移量就为1+1+2,是成员c的倍数，
现在就符合计算结构体大小的第一条：改成员的偏移量是该成员大小的倍数，还有第二条规则：结构体大小是结构体最大成员的倍数，结构体的大小就是各个成员之和，a;2,b:2,c:4加起来就是8，
该结构最大成员为c大小为4，满足第二个条件，所以该结构体的倍数就是8。

示例 2：
struct Data{
    char a;
    int b;
    int64_t c;    该数据类型是有符号的占64位的整形数据类型
    char d;
}
分析：成员a的偏移量就不用看了，上面有说每一个结构体第一个成员的偏移量都为0；但他的大小是1，也就是成员b的偏移量，成员b的大小是4，1不是4的倍数，所以a的大小1应该加上3，就是4，
成员3的偏移量是8，成员c的大小是8，成员c的偏移量是成员c大小的倍数，就不用增加大小，成员d的偏移量是16，成员d的大小是1，偏移量是成员大小的倍数，现在就符合计算结构体大小的第一条：
改成员的偏移量是该成员大小的倍数，还有第二条规则：结构体大小是结构体最大成员的倍数，最大成员为c，大小是8，结构体的大小就是各个成员之和，a：4，b：4，c:8,d:1所有的加起来就是17，
但是17不是8的倍数，所以应该将17+7就是24，所以该结构体的大小就是24。
