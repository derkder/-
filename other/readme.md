记录一些面试没答好的地方:  
## 算法：
#### 1、两个二维无旋转的长方形，如何判断有没有重叠，已知左下角右上角的情况

## 业务：
#### 1. 如何内存优化

## 渲染：
#### 1. 渲染管线流程
#### 2. 深度测试：在gpu渲染管线的哪个状态，&渲染透明物体的那个render queue会用到深度测试吗
//但是好像就是在像素处理阶段的测试合并阶段
//除了early-z位于光栅化阶段之后，像素处理阶段之前，目的是减少进入像素着色阶段的片段（会和透明测试冲突的）
其次，关闭的是深度写入，深度测试还是开的，貌似是因为如果开了深度写入，那么探测到深度值更大的就会直接忽略，而不是和之前深度小的叠加计算了
#### 3、三角形质心公式
#### 4、渲染队列、ui是哪个渲染队列【transparent】、为什么
（半透明物体距离越远越优先渲染，不透明物体正好相反（防止overdraw）。）
Background (1000)最早被渲染的物体的队列。   
Geometry (2000) 不透明物体的渲染队列。大多数物体都应该使用该队列进行渲染，也就是Unity Shader中默认的渲染队列。   
AlphaTest (2450) 有透明通道，需要进行Alpha Test的物体的队列，比在Geomerty中更有效。    
Transparent (3000)半透物体的渲染队列。一般是不写深度的物体，Alpha Blend等的在该队列渲染。【因为ui有些是半透明的，需要这里的alpha混合】         
Overlay (4000)最后被渲染的物体的队列，一般是覆盖效果，比如镜头光晕，屏幕贴片之类的。        
#### 5、为什么半透明物体需要关闭深度写入，同时开启深度测试？
为了保证同一个场景中半透明物体被不透明物体遮挡后该片元能被正常舍弃，要保持深度测试。    
如果开启深度写入，就会直接抛弃深度大的片元而不是混合
#### 6、几种混合公式
color = (A.rgb * A.a) + (B.rgb * (1 - A.a))    
#### 7.解决单个半透明物体之间的渲染问题
第一个Pass写入深度信息不做渲染，第二个Pass再做渲染。
#### 8 RHI
#### 9 透视矫正的实现[注意这里的矫正主要和z轴相关]
[https://zhuanlan.zhihu.com/p/403259571]
产生原因：通过屏幕坐标来计算质心坐标（这时候的屏幕坐标已经收透视矩阵影响了）
解决：
在顶点着色器定义一个新的字段world_z。在经过Modelview之后，将z-c赋值给world_z。[也就是这里的z不让他乘上presenter矩阵了]
然后用这个worldz而不是z进行质心插值计算
#### 10、模型是怎么分成三角面得
说了下全忘光光得曲面塌缩算法
#### 11 early - z

## c++、c#、lua八股
#### 1、类里面装static属性的成员会怎么样 （static有什么用）
  类里面的静态成员属性是所有对象共享的，也就是说它们属于类本身，而不是属于对象。静态成员属性可以通过类名来访问，而不需要创建对象。因此，如果在类里面定义了一个静态成员属性，所有的对象都可以访问该属性，并且该属性的值在整个类范围内都是唯一的。       
 _（static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说**可以不定义类的对象就可以通过类访问这些静态成员**。  
  注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。）_
#### 2、析构函数，对于析构函数一般是虚函数这件事儿， 如果没有写成虚函数，且子类没有写析构函数，会怎么样
chatgpt：
  如果一个父类没有定义析构函数且子类也没有定义析构函数，则编译器会默认生成一个“合成析构函数”（也称为“隐式析构函数”）来处理对象的销毁工作。合成析构函数是一个空函数，什么也不做，只是让编译器知道在销毁对象时应该如何进行清理。
  如果对象中没有需要特殊处理的资源（例如动态分配的内存、打开的文件等），那么合成析构函数通常是足够的。但是，如果对象需要特殊的清理工作，例如释放动态分配的内存或关闭打开的文件，则需要自定义析构函数。
#### 3、虚函数这事儿有什么用 
  答了实现多态，但应该还有别的用
#### 4、新建一个class里面需要什么函数
答了构造、析构、深拷贝，但应该算答得不好
拷贝函数是一定要自己定义的，否则删除的时候拷贝黏贴的ab删其中一个会搞出一个野指针
#### 5、lua的gc机制
三色标记清除法
#### 6、静态多态有哪些
答了模板，又问我模板的原理，他怎么至到要生成那些函数的，还有别的静态多态都不知道
正解函数重载 与 运算符重载（class A的定义中定义class A a class B b之间的+什么的）
#### 6、三种智能指针前两种的具体实现，怎么实现它对应的特质的
整理在big里了
#### 7、物理内存和虚拟内存？
通过一种分页管理机制来进行内存管理。分页管理机制将程序的逻辑地址划分为**固定大小的页**，而物理内存划分为**同样大小的帧**，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。虚拟内存是基于分页存储管理机制的，它允许程序不必将所有的页都放入内存中，而只是将一部分页映射到内存中，另一部分页放在外存上(如磁盘、软盘、USB），当引用到不在内存中的页时，系统产生缺页中断，并从外存中调入该部分页进来，从而产生一种逻辑上内存得到扩充的感觉，实际上内存并没有增大。
#### 8、死锁的必要条件以及进程之间的通信
#### 9、map的底层实现
是红黑树不是平衡二叉树，救命
#### 10、编译器链接的时候，虚函数和普通函数有什么区别
#### 11、进程间还是线程间共享的存储空间：
进程拥有独立的内存空间，而线程是共享进程的内存空间的[https://zhuanlan.zhihu.com/p/352707156]
其中，线程中栈区、程序计数器、栈指针以及寄存器是线程私有的；堆、代码、数据什么的共有
#### 12、引用和指针的区别
指针是内存地址，引用是给已存在变量取一个别名.  
  没有NULL引用,但是有nullptr指针   
  在sizeof中含义不同: 引用结果为引用类型的大小,但指针始终是地址空间,所占字节个数(32位平台占4个字节)     
  引用比指针使用起来相对安全
#### 13、内存泄漏
#### 14、面向对象
1、基于对象。就是题主所说的，只要把数据和函数放在一起就可以了。（外加普通的“继承”，不考虑多态的简单继承还算是基于对象的。）  
2、多态。首先，方法可以在子类中重写；调用对象方法的时候，调用父类还是子类还是孙类的方法，能否自动选择到合适的呢？解决这个问题的设计就是“多态”。
#### 15、c#里ref和out的区别（这两个都是用来代替指针的）
1、ref 必须在方法外面初始化
2、out 必须在方法内部赋值
上面两条对应的就是涉及的时候，用于一个从外向内，一个从内向外
```
void InitializeAndReturn(out int x) {
    x = 10; // 必须在方法内部分配一个值
}
int result;
InitializeAndReturn(out result);
Console.WriteLine(result); // 输出 10
```

#### 16、c++里vector和list的区别。deque[map实现，相比vector前面是可以随便插入的，而且也不用扩容的时候整个挪]
vector数组，list双向链表。vector查找方便，插入删除不方便，list反过来。vector会浪费空间且有迭代器失效的问题，list反过来。



## 其余八股
#### 1、多线程的意义
当时脑袋卡住了多线程只局限于主线程和渲染线程这种，实际线程是并行的呀
面试官非说是提高利用率，这就很扯，应该是并行算出来就快了
#### 2、为什么栈比堆块
有寄存器直接对栈进行访问（esp，ebp），而对堆访问，只能是间接寻址，即第一步将分配的地址放到寄存器，然后取出这个地址的值。  
栈是编译时系统自动分配空间，而堆是动态分配  
#### 3、 ecs
entity是对象，是人物，component才是数据，是unity里中的那个component
#### 4、lua怎么和c#交互的，怎么实现热更新的，什么是里面的解释性语言思想
[lua与c#交互](https://github.com/derkder/plus-ultra/blob/main/BIG/c%23/%E5%8F%8D%E5%B0%84%EF%BC%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%9F%A5%E7%9C%8B%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89%E5%92%8C%E7%89%B9%E6%80%A7%EF%BC%88attribute%EF%BC%89%EF%BC%88%E5%A2%9E%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%EF%BC%89.md)    
Lua是解释型语言，代码在运行时才被解释器一行行动态翻译和执行  
why lua：因为Ios 通过设置内存 No eXecute 限制了 JIT 的使用，而 Lua 可以通过 AoT 等方式编译运行 
#### 5、aa相比ab的优势劣势
#### 6、unreal中的反射机制
[反射](https://github.com/derkder/plus-ultra/blob/main/BIG/c%23/%E5%8F%8D%E5%B0%84%EF%BC%88%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%9F%A5%E7%9C%8B%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89%E5%92%8C%E7%89%B9%E6%80%A7%EF%BC%88attribute%EF%BC%89%EF%BC%88%E5%A2%9E%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%EF%BC%89.md)

