堆溢出:不断的new 一个对象，一直创建新的对象，
栈溢出：死循环或者是递归太深，递归的原因，可能太大，也可能没有终止。



1. 函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。
再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。

2. 动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，
动态空间使用不会造成堆溢出。

3. 数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。

4. 指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。
