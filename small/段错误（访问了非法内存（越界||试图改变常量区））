一、段错误究根到底就是访问了非法内存：
这个内存区要么是不存在的，要么 是受到系统保护的，还有可能是缺少文件或者文件损坏。可能的原因包括：
访问代码段（原因经常是指针未初始化指向了错误的位置或解引用空指针）、访问寄存器
例子1：解引用空指针 int *p=NULL; printf("%d\n",*p); //因为内存低地址为代码段，不可访问？
例子2：访问含有非法值得内存 register int p =10; printf("%d\n",*p); //由于register关键字使变量存储到内核寄存器中，因此不能访问。
野指针：即定义指针时并未对其初始化，其指向的的位置式未知的。对野指针解引用可能造成段错误或者导致程序崩溃。
防止方案：1；定义时初始化为NULL 2;解引用前赋值 3;使用完后指向NULL 每次使用指针之前记得赋值就好了

二、数组越界
如：当使用malloc申请了一页内存，但使用却超出了。 越过数组边界写入数据，在动态分配的内存两端之外写入数据，或改写一些堆管 理数据结构（在动态分配的内存之前的区域写入数据）

三、scanf错误使用：
int b; scanf("%d",b);//应为scanf("%d",&b);

四、指针访问只读内存区：
如：char *p=“abcddf”; *p=‘A’; //其实本质上错误原因和解引用空指针类似，“abcddf”在被定义时放在了代码段或常量区。
//解决方法是将字符串存到数组中，再将指针指向数组头
